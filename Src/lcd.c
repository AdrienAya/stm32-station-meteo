#define STM32F446xx

#include "stm32f4xx.h"
#include <stdint.h>
#include <string.h>

// Table de police 5x7 pixels
// Caractères ASCII 32 à 127 (96 caractères)
// Chaque caractère = 5 colonnes de 8 pixels

uint8_t oled_buffer[1024];

const uint8_t font5x7[][5] = {
    {0x00, 0x00, 0x00, 0x00, 0x00}, // 32  (espace)
    {0x00, 0x00, 0x5F, 0x00, 0x00}, // 33  !
    {0x00, 0x07, 0x00, 0x07, 0x00}, // 34  "
    {0x14, 0x7F, 0x14, 0x7F, 0x14}, // 35  #
    {0x24, 0x2A, 0x7F, 0x2A, 0x12}, // 36  $
    {0x23, 0x13, 0x08, 0x64, 0x62}, // 37  %
    {0x36, 0x49, 0x55, 0x22, 0x50}, // 38  &
    {0x00, 0x05, 0x03, 0x00, 0x00}, // 39  '
    {0x00, 0x1C, 0x22, 0x41, 0x00}, // 40  (
    {0x00, 0x41, 0x22, 0x1C, 0x00}, // 41  )
    {0x14, 0x08, 0x3E, 0x08, 0x14}, // 42  *
    {0x08, 0x08, 0x3E, 0x08, 0x08}, // 43  +
    {0x00, 0x50, 0x30, 0x00, 0x00}, // 44  ,
    {0x08, 0x08, 0x08, 0x08, 0x08}, // 45  -
    {0x00, 0x60, 0x60, 0x00, 0x00}, // 46  .
    {0x20, 0x10, 0x08, 0x04, 0x02}, // 47  /
    {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 48  0
    {0x00, 0x42, 0x7F, 0x40, 0x00}, // 49  1
    {0x42, 0x61, 0x51, 0x49, 0x46}, // 50  2
    {0x21, 0x41, 0x45, 0x4B, 0x31}, // 51  3
    {0x18, 0x14, 0x12, 0x7F, 0x10}, // 52  4
    {0x27, 0x45, 0x45, 0x45, 0x39}, // 53  5
    {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 54  6
    {0x01, 0x71, 0x09, 0x05, 0x03}, // 55  7
    {0x36, 0x49, 0x49, 0x49, 0x36}, // 56  8
    {0x06, 0x49, 0x49, 0x29, 0x1E}, // 57  9
    {0x00, 0x36, 0x36, 0x00, 0x00}, // 58  :
    {0x00, 0x56, 0x36, 0x00, 0x00}, // 59  ;
    {0x08, 0x14, 0x22, 0x41, 0x00}, // 60
    {0x14, 0x14, 0x14, 0x14, 0x14}, // 61  =
    {0x00, 0x41, 0x22, 0x14, 0x08}, // 62  >
    {0x02, 0x01, 0x51, 0x09, 0x06}, // 63  ?
    {0x32, 0x49, 0x79, 0x41, 0x3E}, // 64  @
    {0x7E, 0x11, 0x11, 0x11, 0x7E}, // 65  A
    {0x7F, 0x49, 0x49, 0x49, 0x36}, // 66  B
    {0x3E, 0x41, 0x41, 0x41, 0x22}, // 67  C
    {0x7F, 0x41, 0x41, 0x22, 0x1C}, // 68  D
    {0x7F, 0x49, 0x49, 0x49, 0x41}, // 69  E
    {0x7F, 0x09, 0x09, 0x09, 0x01}, // 70  F
    {0x3E, 0x41, 0x49, 0x49, 0x7A}, // 71  G
    {0x7F, 0x08, 0x08, 0x08, 0x7F}, // 72  H
    {0x00, 0x41, 0x7F, 0x41, 0x00}, // 73  I
    {0x20, 0x40, 0x41, 0x3F, 0x01}, // 74  J
    {0x7F, 0x08, 0x14, 0x22, 0x41}, // 75  K
    {0x7F, 0x40, 0x40, 0x40, 0x40}, // 76  L
    {0x7F, 0x02, 0x0C, 0x02, 0x7F}, // 77  M
    {0x7F, 0x04, 0x08, 0x10, 0x7F}, // 78  N
    {0x3E, 0x41, 0x41, 0x41, 0x3E}, // 79  O
    {0x7F, 0x09, 0x09, 0x09, 0x06}, // 80  P
    {0x3E, 0x41, 0x51, 0x21, 0x5E}, // 81  Q
    {0x7F, 0x09, 0x19, 0x29, 0x46}, // 82  R
    {0x46, 0x49, 0x49, 0x49, 0x31}, // 83  S
    {0x01, 0x01, 0x7F, 0x01, 0x01}, // 84  T
    {0x3F, 0x40, 0x40, 0x40, 0x3F}, // 85  U
    {0x1F, 0x20, 0x40, 0x20, 0x1F}, // 86  V
    {0x3F, 0x40, 0x38, 0x40, 0x3F}, // 87  W
    {0x63, 0x14, 0x08, 0x14, 0x63}, // 88  X
    {0x07, 0x08, 0x70, 0x08, 0x07}, // 89  Y
    {0x61, 0x51, 0x49, 0x45, 0x43}, // 90  Z
    {0x00, 0x7F, 0x41, 0x41, 0x00}, // 91  [
    {0x02, 0x04, 0x08, 0x10, 0x20}, // 92  backslash
    {0x00, 0x41, 0x41, 0x7F, 0x00}, // 93  ]
    {0x04, 0x02, 0x01, 0x02, 0x04}, // 94  ^
    {0x40, 0x40, 0x40, 0x40, 0x40}, // 95  _
    {0x00, 0x01, 0x02, 0x04, 0x00}, // 96  `
    {0x20, 0x54, 0x54, 0x54, 0x78}, // 97  a
    {0x7F, 0x48, 0x44, 0x44, 0x38}, // 98  b
    {0x38, 0x44, 0x44, 0x44, 0x20}, // 99  c
    {0x38, 0x44, 0x44, 0x48, 0x7F}, // 100 d
    {0x38, 0x54, 0x54, 0x54, 0x18}, // 101 e
    {0x08, 0x7E, 0x09, 0x01, 0x02}, // 102 f
    {0x0C, 0x52, 0x52, 0x52, 0x3E}, // 103 g
    {0x7F, 0x08, 0x04, 0x04, 0x78}, // 104 h
    {0x00, 0x44, 0x7D, 0x40, 0x00}, // 105 i
    {0x20, 0x40, 0x44, 0x3D, 0x00}, // 106 j
    {0x7F, 0x10, 0x28, 0x44, 0x00}, // 107 k
    {0x00, 0x41, 0x7F, 0x40, 0x00}, // 108 l
    {0x7C, 0x04, 0x18, 0x04, 0x78}, // 109 m
    {0x7C, 0x08, 0x04, 0x04, 0x78}, // 110 n
    {0x38, 0x44, 0x44, 0x44, 0x38}, // 111 o
    {0x7C, 0x14, 0x14, 0x14, 0x08}, // 112 p
    {0x08, 0x14, 0x14, 0x18, 0x7C}, // 113 q
    {0x7C, 0x08, 0x04, 0x04, 0x08}, // 114 r
    {0x48, 0x54, 0x54, 0x54, 0x20}, // 115 s
    {0x04, 0x3F, 0x44, 0x40, 0x20}, // 116 t
    {0x3C, 0x40, 0x40, 0x20, 0x7C}, // 117 u
    {0x1C, 0x20, 0x40, 0x20, 0x1C}, // 118 v
    {0x3C, 0x40, 0x30, 0x40, 0x3C}, // 119 w
    {0x44, 0x28, 0x10, 0x28, 0x44}, // 120 x
    {0x0C, 0x50, 0x50, 0x50, 0x3C}, // 121 y
    {0x44, 0x64, 0x54, 0x4C, 0x44}, // 122 z
    {0x00, 0x08, 0x36, 0x41, 0x00}, // 123 {
    {0x00, 0x00, 0x7F, 0x00, 0x00}, // 124 |
    {0x00, 0x41, 0x36, 0x08, 0x00}, // 125 }
    {0x10, 0x08, 0x08, 0x10, 0x08}, // 126 ~
    {0x00, 0x00, 0x00, 0x00, 0x00}  // 127 DEL
};



void SSD1306_Update_Screen(void) {
    // 1. Définir la zone de colonnes (0-127)
    SSD1306_Write_Command(0x21);  // Set Column Address
    SSD1306_Write_Command(0x00);  // Start = 0
    SSD1306_Write_Command(0x7F);  // End = 127

    // 2. Définir la zone de pages (0-7)
    SSD1306_Write_Command(0x22);  // Set Page Address
    SSD1306_Write_Command(0x00);  // Start = 0
    SSD1306_Write_Command(0x07);

    I2C_Start();
    I2C_Write_Addr(0x78);
    I2C_Write_Data(0x40);
    for(uint16_t i = 0; i<1024 ; i++){

    	I2C_Write_Data(oled_buffer[i]);
    }
    I2C_Stop();

}


void SSD1306_SetPixel(uint8_t x,uint8_t y,uint8_t color){

	if(x>=128 || y>=64) return;

	// 1. Vérifier limites
	    // 2. Calculer index et bit
	    // 3. Allumer ou éteindre le bit

	uint16_t index = x + (y/8)*128;

	uint8_t bit_position = y % 8;

	if(color){

		oled_buffer[index] |= (1<<bit_position);
	}
	else{
		oled_buffer[index] &= ~(1<<bit_position);
	}

}

void SSD1306_DrawChar(uint8_t x, uint8_t y, char c){

	uint16_t index = c - 32;

	for(uint8_t i= 0; i<5;i++){

           uint8_t colum_data = font5x7[index][i];
           for(uint8_t r= 0; r<8; r++){

        	   if(colum_data & (1<<r)){

        		   SSD1306_SetPixel(x+i,y+r, 1);
        	   }
           }
	}

}

void SSD1306_DrawString(uint8_t x, uint8_t y, const char* str) {
    uint8_t cur_x = x;

    while(*str) {
        SSD1306_DrawChar(cur_x, y, *str);
        cur_x += 6;  // 5 pixels + 1 espace
        str++;
    }
}

void SSD1306_Write_Command(uint8_t cmd) {
    I2C_Start();
    I2C_Write_Addr(0x78);
    I2C_Write_Data(0x00);
    I2C_Write_Data(cmd);
    I2C_Stop();
}

void SSD1306_Write_Data(uint8_t data){
	 I2C_Start();
	 I2C_Write_Addr(0x78);
	 I2C_Write_Data(data);
	 I2C_Stop();

}

void SSD1306_Init(void){
    // Attendre stabilisation de l'écran au démarrage
    delay_ms(100);

    // 1. Éteindre l'écran pendant la configuration
    SSD1306_Write_Command(0xAE);  // Display OFF

    // 2. Configurer le mode d'adressage mémoire
    SSD1306_Write_Command(0x20);  // Set Memory Addressing Mode
    SSD1306_Write_Command(0x00);  // 0x00 = Horizontal (recommandé)
                                   // 0x01 = Vertical
                                   // 0x02 = Page (par défaut)

    // 3. Définir l'adresse de départ (colonnes)
    SSD1306_Write_Command(0x00);  // Set Lower Column Start Address (0x00-0x0F)
    SSD1306_Write_Command(0x10);  // Set Higher Column Start Address (0x10-0x1F)

    // 4. Définir la ligne de départ
    SSD1306_Write_Command(0x40);  // Set Start Line Address (0x40-0x7F)
                                   // 0x40 = ligne 0

    // 5. Configurer le contraste (luminosité)
    SSD1306_Write_Command(0x81);  // Set Contrast Control
    SSD1306_Write_Command(0x7F);  // Valeur du contraste (0x00-0xFF)
                                   // 0x7F = moyen, 0xFF = max

    // 6. Inverser ou non les colonnes (flip horizontal)
    SSD1306_Write_Command(0xA1);  // Set Segment Re-map
                                   // 0xA0 = normal (colonne 0 mapped to SEG0)
                                   // 0xA1 = inversé (colonne 127 mapped to SEG0)

    // 7. Mode d'affichage normal ou inversé (noir/blanc)
    SSD1306_Write_Command(0xA6);  // Set Normal/Inverse Display
                                   // 0xA6 = normal (0=noir, 1=blanc)
                                   // 0xA7 = inversé (0=blanc, 1=noir)

    // 8. Configurer le multiplex ratio (hauteur active)
    SSD1306_Write_Command(0xA8);  // Set Multiplex Ratio
    SSD1306_Write_Command(0x3F);  // 0x3F = 64 lignes (pour 128x64)
                                   // 0x1F = 32 lignes (pour 128x32)

    // 9. Désactiver l'affichage complet forcé
    SSD1306_Write_Command(0xA4);  // Entire Display ON
                                   // 0xA4 = normal (utilise la RAM)
                                   // 0xA5 = force tous les pixels ON

    // 10. Configurer le décalage vertical de l'affichage
    SSD1306_Write_Command(0xD3);  // Set Display Offset
    SSD1306_Write_Command(0x00);  // Pas de décalage (0x00-0x3F)

    // 11. Configurer l'horloge et la fréquence d'oscillateur
    SSD1306_Write_Command(0xD5);  // Set Display Clock Divide Ratio
    SSD1306_Write_Command(0x80);  // Ratio par défaut
                                   // Bits 0-3 = divise ratio (1-16)
                                   // Bits 4-7 = fréquence oscillateur

    // 12. Configurer la période de pré-charge
    SSD1306_Write_Command(0xD9);  // Set Pre-charge Period
    SSD1306_Write_Command(0xF1);  // 0xF1 pour alimentation interne
                                   // Bits 0-3 = Phase 1 (1-15 DCLK)
                                   // Bits 4-7 = Phase 2 (1-15 DCLK)

    // 13. Configurer les broches matérielles COM
    SSD1306_Write_Command(0xDA);  // Set COM Pins Hardware Config
    SSD1306_Write_Command(0x12);  // 0x12 pour 128x64
                                   // 0x02 pour 128x32
                                   // Bit 4 = Alternative (1) ou Sequential (0)
                                   // Bit 5 = Enable left/right remap

    // 14. Configurer le niveau VCOMH
    SSD1306_Write_Command(0xDB);  // Set VCOMH Deselect Level
    SSD1306_Write_Command(0x40);  // ~0.77 x VCC
                                   // 0x00 = ~0.65 x VCC
                                   // 0x20 = ~0.77 x VCC
                                   // 0x30 = ~0.83 x VCC

    // 15. Inverser ou non les lignes (flip vertical)
    SSD1306_Write_Command(0xC8);  // Set COM Output Scan Direction
                                   // 0xC0 = normal (scan from COM0 to COM63)
                                   // 0xC8 = inversé (scan from COM63 to COM0)

    // 16. Définir l'adresse de page de départ
    SSD1306_Write_Command(0xB0);  // Set Page Start Address (0xB0-0xB7)
                                   // 0xB0 = page 0

    // 17. CRITIQUE : Activer la pompe de charge interne
    SSD1306_Write_Command(0x8D);  // Charge Pump Setting
    SSD1306_Write_Command(0x14);  // 0x14 = Enable charge pump
                                   // 0x10 = Disable
                                   // SANS ÇA L'ÉCRAN RESTE NOIR !

    // 18. Allumer l'écran
    SSD1306_Write_Command(0xAF);  // Display ON
}

void SSD1306_Clear_Buffer(void){

	for(uint16_t i= 0; i< 1024 ; i++){

		oled_buffer[i] = 0x00;
	}
}
